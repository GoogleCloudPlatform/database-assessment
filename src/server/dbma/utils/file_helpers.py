# Copyright 2022 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import logging
from tempfile import TemporaryDirectory
from typing import TYPE_CHECKING, Generator, Union

from packaging.version import LegacyVersion, Version
from packaging.version import parse as parse_version

if TYPE_CHECKING:
    from pathlib import Path


__all__ = [
    "get_collection_id_from_key",
    "get_collection_key_from_file",
    "get_db_version_from_file",
    "get_version_from_file",
    "get_temp_dir",
]

logger = logging.getLogger()

ScriptVersionType = Union[Version, LegacyVersion]


class InvalidFileError(Exception):
    """Invalid File Exception"""


def get_temp_dir() -> "Generator[TemporaryDirectory, None, None]":
    with TemporaryDirectory() as d:
        yield d  # type: ignore


def get_version_from_file(file: "Path") -> "Union[LegacyVersion, Version]":
    """Get the correct collection config for the specified version

    Args:
        version (str): The version number of compare

    Returns:
        CollectionConfig: _description_
    """
    try:
        object_meta = file.stem.split("__", maxsplit=1)[1]
        script_version = object_meta.split("_", maxsplit=2)[1]
        version = parse_version(script_version)
        return version
    except (ValueError, IndexError) as e:
        logger.warning(
            "Could not recognize collection from compressed file."
            "  The collection input files should not be modified from what is generated by the collection scripts %s",
            e,
        )
        raise InvalidFileError from e


def get_collection_key_from_file(file: "Path") -> str:
    """Get the correct collection config for the specified version

    Args:
        file (Path): The version number of compare

    Returns:
        CollectionConfig: _description_
    """
    try:
        object_meta = file.stem.split("__", maxsplit=1)[1]
        collection_key = object_meta.split("_", maxsplit=2)[2]
        return collection_key.removesuffix(".tar").removesuffix(".log").removesuffix(".csv")
    except (ValueError, IndexError) as e:
        raise InvalidFileError from e


def get_collection_id_from_key(key: str) -> str:
    """Get the correct collection config for the specified version

    Args:
        key (str): the collection key

    Returns:
        str: the ID portion of the collection key
    """
    try:
        collection_id = key.rsplit(".", maxsplit=1)[1]
        return collection_id
    except (ValueError, IndexError) as e:
        raise InvalidFileError from e


def get_db_version_from_file(file: "Path") -> str:
    """Get the correct collection config for the specified version

    Args:
        file (Path): The version number of compare

    Returns:
        str: _description_
    """
    try:
        object_meta = file.stem.rsplit("__", maxsplit=2)[1]
        db_version = object_meta.split("_", maxsplit=2)[0]
        return db_version
    except (ValueError, IndexError) as e:
        raise InvalidFileError from e


def get_schema_type_from_file(file: "Path") -> str:
    """Get the file type from the file name.

    Args:
        file (Path): The version number of compare

    Returns:
        str: The type of file it is
    """
    try:
        object_meta = file.stem.rsplit("__", maxsplit=2)[0]
        schema_type = object_meta.split("_", maxsplit=2)[0]
        return schema_type
    except (ValueError, IndexError) as e:
        raise InvalidFileError from e
