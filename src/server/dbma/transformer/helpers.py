import tarfile as tf
import zipfile as zf
from pathlib import Path
from tempfile import TemporaryDirectory
from typing import Generator, Union

from packaging.version import LegacyVersion, Version
from packaging.version import parse as parse_version

from dbma import log

__all__ = [
    "get_collection_id_from_key",
    "get_collection_key_from_file",
    "get_db_version_from_file",
    "get_version_from_file",
    "get_temp_dir",
    "extract_collection",
]

logger = log.get_logger()

ScriptVersionType = Union[Version, LegacyVersion]


class InvalidFileError(Exception):
    """Invalid File Exception"""


def get_temp_dir() -> "Generator[TemporaryDirectory, None, None]":
    with TemporaryDirectory() as d:
        yield d  # type: ignore


def extract_collection(
    collection_id: str, collection_archive: "Path", extract_path: "Union[TemporaryDirectory,Path]"
) -> "list[Path]":
    """Extracts the specified collection to the specified directory."""
    logger.info("ðŸ”Ž searching %s for files and extracting to %s", collection_archive.name, extract_path)
    if collection_archive.suffix in {".gz", ".tgz"}:
        with tf.TarFile.open(collection_archive, "r|gz") as archive:
            archive.extractall(str(extract_path))
    elif collection_archive.suffix in {".zip"}:
        with zf.ZipFile(collection_archive, "r") as archive:
            archive.extractall(str(extract_path))
    for file_to_rename in list(Path(str(extract_path)).glob(f"*{collection_id}.log")):
        new_path = file_to_rename.rename(f"{file_to_rename.parent}/{file_to_rename.stem}.csv")
        logger.info("renaming file that ends with 'log' extension to 'csv': %s", new_path.stem)
    return list(Path(str(extract_path)).glob(f"*{collection_id}.csv"))


def get_version_from_file(file: "Path") -> "Union[LegacyVersion, Version]":
    """Get the correct collection config for the specified version

    Args:
        version (str): The version number of compare

    Returns:
        CollectionConfig: _description_
    """
    try:
        object_meta = file.stem.split("__", maxsplit=1)[1]
        script_version = object_meta.split("_", maxsplit=2)[1]
        version = parse_version(script_version)
        return version
    except (ValueError, IndexError) as e:
        logger.warning(
            "Could not recognize collection from compressed file."
            "  The collection input files should not be modified from what is generated by the collection scripts %s",
            e,
        )
        raise InvalidFileError from e


def get_collection_key_from_file(file: "Path") -> str:
    """Get the correct collection config for the specified version

    Args:
        file (Path): The version number of compare

    Returns:
        CollectionConfig: _description_
    """
    try:
        object_meta = file.stem.split("__", maxsplit=1)[1]
        collection_key = object_meta.split("_", maxsplit=2)[2]
        return collection_key.removesuffix(".tar").removesuffix(".log").removesuffix(".csv")
    except (ValueError, IndexError) as e:
        raise InvalidFileError from e


def get_collection_id_from_key(key: str) -> str:
    """Get the correct collection config for the specified version

    Args:
        key (str): the collection key

    Returns:
        str: the ID portion of the collection key
    """
    try:
        collection_id = key.rsplit(".", maxsplit=1)[1]
        return collection_id
    except ValueError as e:
        raise InvalidFileError from e


def get_db_version_from_file(file: "Path") -> str:
    """Get the correct collection config for the specified version

    Args:
        file (Path): The version number of compare

    Returns:
        CollectionConfig: _description_
    """
    try:
        object_meta = file.stem.rsplit("__", maxsplit=2)[0]
        db_version = object_meta.split("_", maxsplit=2)[0]
        return db_version
    except (ValueError, IndexError) as e:
        raise InvalidFileError from e
